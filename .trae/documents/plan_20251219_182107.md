# OAuth2 Password Flow + JWT + Refresh Tokens 实现计划

## 一、实现目标

1. **实现OAuth2 Password Flow**：使用标准的OAuth2密码流程进行用户认证
2. **JWT令牌生成与验证**：使用JWT作为认证令牌，支持access token和refresh token
3. **Refresh Token机制**：实现令牌刷新功能，提高安全性
4. **HttpOnly Cookie存储**：使用HttpOnly Cookie存储refresh token，防止XSS攻击
5. **更新现有服务**：将所有适合使用Redis的服务更新为使用`get_db_and_redis`
6. **角色权限控制**：实现基于角色的访问控制

## 二、实现步骤

### 1. 依赖安装

安装必要的依赖库：
- `python-jose`：用于JWT生成和验证
- `passlib`：用于密码哈希
- `python-multipart`：用于处理表单数据

### 2. 配置更新

在`config.py`中添加JWT相关配置：
- SECRET_KEY：JWT签名密钥
- ALGORITHM：JWT算法
- ACCESS_TOKEN_EXPIRE_MINUTES：access token有效期
- REFRESH_TOKEN_EXPIRE_DAYS：refresh token有效期

### 3. 认证服务实现

创建`app/services/auth_service.py`，包含：
- 密码哈希和验证
- JWT令牌生成
- JWT令牌验证
- Refresh token管理

### 4. 认证路由实现

创建`app/routes/auth.py`，包含：
- `/token`：获取access token和refresh token
- `/refresh`：使用refresh token获取新的access token
- `/logout`：注销登录，清除refresh token

### 5. 依赖注入实现

在`app/dependencies.py`中添加：
- `get_current_user`：获取当前用户
- `get_current_active_user`：获取当前活跃用户
- `get_current_admin`：获取当前管理员用户

### 6. 更新现有服务

将所有需要使用Redis的服务更新为使用`get_db_and_redis`：
- `app/services/detection/*_service.py`
- `app/services/user/*_service.py`
- `app/services/admin/*_service.py`

### 7. 角色权限控制

在`app/models/user.py`中确认角色字段存在，在服务层实现角色验证：
- 普通用户角色
- 管理员角色

## 三、技术要点

### 1. JWT实现

- 使用`python-jose`库生成和验证JWT
- Access token包含用户ID和角色信息
- Refresh token用于获取新的access token，存储在HttpOnly Cookie中

### 2. Redis使用

- 所有服务统一使用`get_db_and_redis`获取连接
- 读取操作优先从Redis获取，不存在则从数据库获取并更新Redis
- 写入操作同时更新数据库和Redis
- 删除操作同时删除数据库记录和Redis缓存

### 3. 安全性

- 使用`passlib`进行密码哈希
- Access token有效期设置为15分钟
- Refresh token存储在HttpOnly Cookie中，防止XSS攻击
- Refresh token有效期设置为7天
- 支持令牌自动刷新，提高用户体验

### 4. 代码复用

- 利用现有DAL层，避免重复代码
- 统一使用`get_db_and_redis`依赖函数
- 复用现有的用户模型和服务结构

## 四、实现细节

### 1. 认证服务设计

```python
class AuthService:
    @staticmethod
    def create_access_token(data: dict, expires_delta: timedelta = None) -> str:
        # 生成access token
        pass
    
    @staticmethod
    def create_refresh_token(data: dict, expires_delta: timedelta = None) -> str:
        # 生成refresh token
        pass
    
    @staticmethod
    def verify_token(token: str, credentials_exception) -> dict:
        # 验证token
        pass
    
    @staticmethod
    def authenticate_user(username: str, password: str) -> Optional[User]:
        # 验证用户
        pass
```

### 2. 路由设计

```python
# 登录路由
@app.post("/token", response_model=Token)
async def login_for_access_token(
    form_data: OAuth2PasswordRequestForm = Depends(),
    response: Response = Response()
):
    # 验证用户
    # 生成tokens
    # 设置refresh token到HttpOnly Cookie
    pass

# 刷新token路由
@app.post("/refresh", response_model=Token)
async def refresh_access_token(
    refresh_token: Optional[str] = Cookie(None)
):
    # 验证refresh token
    # 生成新的access token
    pass

# 注销登录路由
@app.post("/logout")
async def logout(
    response: Response = Response()
):
    # 清除refresh token Cookie
    pass
```

### 3. 依赖设计

```python
# 获取当前用户
def get_current_user(
    token: str = Depends(oauth2_scheme)
) -> User:
    # 验证access token
    pass

# 获取当前活跃用户
def get_current_active_user(
    current_user: User = Depends(get_current_user)
) -> User:
    # 检查用户是否活跃
    pass

# 获取当前管理员用户
def get_current_admin(
    current_user: User = Depends(get_current_active_user)
) -> User:
    # 检查用户是否为管理员
    pass
```

## 五、服务更新计划

将以下服务更新为使用`get_db_and_redis`：

1. **检测相关服务**：
   - DetectionStandardService
   - DetectionItemService
   - CategoryService
   - DelegationFormTemplateService
   - DetectionGuideService
   - DetectionGroupService

2. **用户相关服务**：
   - UserService
   - APIPermissionService
   - RoleService

3. **管理员服务**：
   - DetectionAdminService
   - UserAdminService

## 六、测试计划

1. **单元测试**：测试认证服务的各个方法
2. **集成测试**：测试登录、刷新令牌、注销等流程
3. **安全性测试**：验证HttpOnly Cookie设置、令牌过期处理
4. **性能测试**：测试Redis缓存的效果

## 七、预期效果

1. ✅ 实现完整的OAuth2 Password Flow认证流程
2. ✅ 支持access token和refresh token
3. ✅ 提高系统安全性，防止XSS攻击
4. ✅ 所有适合使用Redis的服务都使用`get_db_and_redis`
5. ✅ 实现基于角色的访问控制
6. ✅ 代码结构清晰，复用现有组件

## 八、风险评估

1. **依赖冲突**：新安装的依赖可能与现有依赖冲突
2. **性能影响**：Redis连接失败可能影响服务性能
3. **安全风险**：密钥管理不当可能导致安全问题
4. **兼容性问题**：现有代码可能需要调整以适应新的认证机制

## 九、应对措施

1. **依赖管理**：仔细检查依赖版本，确保兼容性
2. **错误处理**：添加适当的异常处理，确保Redis连接失败时系统仍能正常运行
3. **密钥安全**：从环境变量读取密钥，避免硬编码
4. **渐进式更新**：逐步更新现有服务，确保每个服务都能正常工作

通过以上计划，我们可以实现一个安全、高效的认证系统，同时更新现有服务以充分利用Redis缓存，提高系统性能。