# 实现分类状态递归管理功能

## 功能需求
1. 禁用分类时，递归禁用其所有子类
2. 启用子类时，递归启用其所有上级分类，直到顶级分类

## 技术分析
- **当前实现**：CategoryService.update方法仅更新单个分类的状态，没有处理父子分类的关联状态
- **需要修改**：CategoryService.update方法，添加递归处理逻辑
- **数据访问**：使用CategoryDAL.get_by_parent_id获取子分类，使用CategoryDAL.get_by_id获取父分类
- **事务管理**：所有状态更新操作需在同一个事务中完成

## 实现步骤

### 1. 修改CategoryService.update方法
- **位置**：`app/services/detection/category_service.py`
- **功能**：添加状态变更时的递归处理逻辑
- **核心逻辑**：
  - 当更新状态为禁用(0)时，递归禁用所有子分类
  - 当更新状态为启用(1)时，递归启用所有上级分类

### 2. 实现递归禁用子分类方法
- **方法名**：`_recursively_disable_children`
- **功能**：递归禁用指定分类的所有子分类
- **参数**：
  - `category_id`：当前分类ID
  - `category_dal`：CategoryDAL实例
  - `db`：数据库会话
- **实现**：
  - 获取当前分类的所有直接子分类
  - 遍历子分类，更新状态为禁用
  - 递归调用自身，处理子分类的子分类

### 3. 实现递归启用上级分类方法
- **方法名**：`_recursively_enable_parents`
- **功能**：递归启用指定分类的所有上级分类
- **参数**：
  - `category_id`：当前分类ID
  - `category_dal`：CategoryDAL实例
  - `db`：数据库会话
- **实现**：
  - 获取当前分类的父分类
  - 如果父分类存在且状态为禁用，更新父分类状态为启用
  - 递归调用自身，处理父分类的父分类，直到顶级分类

### 4. 确保事务一致性
- 所有数据库操作在同一个事务中执行
- 任何一步失败时，回滚整个事务

## 代码修改要点

### CategoryService.update方法修改
1. 在更新分类状态前，检查状态是否发生变化
2. 如果状态从启用变为禁用，调用递归禁用方法
3. 如果状态从禁用变为启用，调用递归启用方法
4. 所有操作在同一个数据库事务中完成

### 递归方法实现
1. 使用已有的数据库会话，避免创建新的会话
2. 递归处理时，保持数据库会话的一致性
3. 错误处理：捕获并记录递归过程中的异常

## 测试计划
1. **禁用分类测试**：
   - 创建一个分类树：顶级分类A → 分类B → 分类C
   - 禁用分类B，验证分类B和分类C都被禁用

2. **启用子类测试**：
   - 创建一个分类树：顶级分类A(禁用) → 分类B(禁用) → 分类C(禁用)
   - 启用分类C，验证分类A、B、C都被启用

3. **边界情况测试**：
   - 禁用顶级分类，验证所有子分类都被禁用
   - 启用顶级分类，验证只有自身状态变化
   - 状态未变化时，验证不执行递归操作

## 预期效果
- 分类状态管理更加智能，减少手动操作
- 确保分类树的状态一致性
- 提高系统的易用性和数据完整性